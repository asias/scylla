File level encryption in scylla enterprise
==========================================

File encryption in scylla enterprise is done by "block-level" encryption via a file_impl implementation
that transparently wraps file IO transforming data to/from encrypted state. 

Encryption is algorithm agnostic insofar that any symmetric algorithm supported by the key wrapper, i.e. available in the OpenSSL EVP crypt library.     

The wrapper uses a user provided symmetric key coupled with `ESSIV` block initialization vector calculation.
*NOTE*: the data file itself does *not* keep track of the key used to encrypt data, thus an external meta data provider is required to map files to their keys, and is solely the users responsibility.

File block encryption does not use padding, since it relies on 1:1 input data size to output data size. 

The file is divided in `N` blocks of 4096 bytes size. Each block is encrypted (without padding) with the provided key and block mode, using an IV derived via `ESSIV`. See https://en.wikipedia.org/wiki/Disk_encryption_theory#Encrypted_salt-sector_initialization_vector_(ESSIV)

Each `ESSIV` IV is generated by a `block key`. This is created by generating the `SHA256` hash of the provided data encryption key bytes, truncated to `block_key_len/8` and generating an AES/ECB key using this data.

The IV itself is then generated by 

``
bytes tmp[<key block size, typically 16>] = { 0, ..., uint64_t-little-endian(<block number>) }
iv = block_key->encrypt(tmp);
``

Padding/truncation
==================

All encryption is done unpadded. To handle file sizes we use a simplified padding scheme:

Since all writes are assumed to be done by us, and must be aligned (scylla requirement),
we can assume in turn that any resizing should be made by truncation.

If a file is truncated to a size not a multiple of our `key block size` (typically 16), we add the same size to the actual truncation size.
When reading an encrypted file, we check the file size. If we're reading from a file with an unaliged size, we know there are `key block size` bytes of padding at the end. This data can thus be discarded when reading (post decrypting), and file size query methods adjust the returned values accordingly.
